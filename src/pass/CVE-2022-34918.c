#include "stdbool.h"
#include <stdlib.h>

extern int nd(void);
#define ALLOCA alloca
/*
 * Linux NetFilter Buf Overflow Bug Demo
 *
 * CVE-2022-34918,
 * follow <====== (1), (2), (3) until the buffer overflow position
 *
 * */

struct nft_set {
  int  dlen;
  char* data;
};

struct nft_data_desc {
  enum TYPE {
    NFT_DATA_VERDICT = 0,
    NFT_DATA_OTHER = 1
  };
  enum TYPE type;
  int len;
};

struct nft_data {
  char* data;
};

void *nft_set_elem_init(const struct nft_set *set,
                        const char *data)
{
  if (data)
    memcpy(data, set->data, set->dlen);         //   <===== (7)
}

int nft_setelem_parse_data( struct nft_set *set,
                           struct nft_data_desc *desc,
                           struct nft_data *data)
{
  int err;
  err = nft_data_init(data, desc);     //     <===== (4)
  if (err < 0)
    return err;

  if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {  //  <===== (5) does not release
    nft_data_release(data, desc);
    return -1;
  }

  return 0;
}

int nft_add_set_elem(struct nft_set *set) {
  struct nft_data data;
  struct nft_data_desc desc;
  desc.len = set->dlen;

  if (nd()) {
    nft_setelem_parse_data(set, &desc, &data); // <===== (2)
  }
  nft_set_elem_init(set, data.data); //<==== (6)
}

int nft_data_init(struct nft_data *data, struct nft_data_desc *desc) {
    if (nd()) {
      data->data = (char*)ALLOC(desc->len);
      desc->type = NFT_DATA_VERDICT;
    } else {
      data->data = (char*)ALLOC(desc->len - 2);
      desc->type = NFT_DATA_VERDICT; // <======  (3)
    }
}

int nft_data_release(struct nft_data *data, struct nft_data_desc *desc ) {
   free(data->data);
   data->data = NULL;
   desc->len = 0;
}

int main() {
  struct nft_set set;
  set.dlen = 10;
  set.data = (char*)ALLOCA(set.dlen);
  nft_add_set_elem(&set); // <====== (1)
}