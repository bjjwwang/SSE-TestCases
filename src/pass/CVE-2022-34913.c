/*
CVE-ID: CVE-2022-34913
Description: md2roff 1.7 has a stack-based buffer overflow via a Markdown file containing a large number of consecutive characters to be processed. NOTE: the vendor's position is that the product is not intended for untrusted input. 
*/

#include <stdbool.h>
#include <time.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <errno.h>
#include <regex.h>

#include <assert.h>

void md2roff(const char *docname, const char *source) {
	const char *p = source;
	char appname[64];
	
	if (true) { //nd()
		while ( isspace(*p) ) {
			p ++;
		}
		// no header specified
		if (p[0] != '#' || !isblank(p[1]) ) {
			//assert(sizeof(appname)/sizeof(appname[0]) < 64);
			strcpy(appname, docname); //potential buffer overflow
		}
	}
}

char *loadfile(const char *filename) {
	int len = -1;
	FILE *fp;
	char *buf = NULL;

	if ( filename != NULL ) {
		fp = fopen(filename, "r");
		if (fp == NULL) {
			printf("Unable to open '%s'", filename);
			exit(EXIT_FAILURE);
		}
		if (fseek(fp, 0L, SEEK_END) == -1) {
			printf("fseek failed");
			exit(EXIT_FAILURE);
		}
		len = ftell(fp);
		if (len == -1) {
			printf("ftell failed");
			exit(EXIT_FAILURE);
		}
		if(fseek(fp, 0L, SEEK_SET) == -1) {
			printf("fseek failed");
			exit(EXIT_FAILURE);
		}
		buf = (char *) malloc(len+1);
		if(fread(buf, len, 1, fp) == -1) {
			printf("fread failed");
			exit(EXIT_FAILURE);
		}
		buf[len] = '\0';
		fclose(fp);
	}

	return buf;
}

int main(int argc, char *argv[]) {
	int files[64];
	int fc = 0;
	
	for ( int i = 1; i < argc; i ++ ) {
		if ( argv[i][0] != '-' ) {
			//assert(fc < 64);
			files[fc] = i; //potential buffer overflow
			fc ++;
		}
	}
	
	for ( int i = 0; i < fc; i ++ ) {
		char *buf = loadfile(argv[files[i]]);
		md2roff(argv[files[i]], buf);
		free(buf);
	}
}
